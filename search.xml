<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2023%2F03%2F08%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Django开发中X-Frame-Options-to-deny问题记录解决]]></title>
    <url>%2F2020%2F01%2F29%2FDjango%E5%BC%80%E5%8F%91%E4%B8%ADX-Frame-Options-to-deny%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[问题描述:Django框架写网页项目时，用到插件editor.md实现网页端富文本编辑器，实现图片跨域上传时，返回Json值成功，但MarkDown编辑器中没有图片 上传成功但没有显示图片地址 浏览器F12打开调试模式后发现异常 报错如下：1Refused to display &apos;http://127.0.0.1:8000/&apos; in a frame because it set &apos;X-Frame-Options&apos; to &apos;deny&apos;. 由于借用的是开源模板，而且图片使用的是跨域上传方式，将文件存放在腾讯云平台cos中，搜索查询到的问题是frame架构中间人攻击的相关bug，在谷歌上找到线索，问题原因：（官方文档的答案） clickjacking中间件和装饰器提供了易于使用的保护，以防止clickjacking。当恶意站点诱使用户单击他们已加载到隐藏框架或iframe中的另一个站点的隐藏元素时，会发生这种类型的攻击。 现代浏览器采用X-Frame-Options HTTP标头，该标头指示是否允许在框架或iframe中加载资源。如果响应包含标头值为的标头，SAMEORIGIN则浏览器将仅在请求源自同一站点的情况下将资源加载到框架中。如果将标头设置为，DENY则无论哪个站点发出请求，浏览器都将阻止资源加载到框架中。 Django提供了几种在您的网站响应中包含此标头的方法： 在所有响应中设置标头的中间件。 一组视图装饰器，可用于覆盖中间件或仅为某些视图设置标头。 如果X-Frame-OptionsHTTP头尚未在响应中出现，则仅由中间件或视图装饰器设置。 在Django 3.0中进行了更改： 设置的默认值X_FRAME_OPTIONS从更改SAMEORIGIN为DENY 出现问题的原因在setting中的中间件： 123456789MIDDLEWARE = [ &apos;django.middleware.security.SecurityMiddleware&apos;, &apos;django.contrib.sessions.middleware.SessionMiddleware&apos;, &apos;django.middleware.common.CommonMiddleware&apos;, &apos;django.middleware.csrf.CsrfViewMiddleware&apos;, &apos;django.contrib.auth.middleware.AuthenticationMiddleware&apos;, &apos;django.contrib.messages.middleware.MessageMiddleware&apos;, &apos;django.middleware.clickjacking.XFrameOptionsMiddleware&apos;,] 解决方法 注释掉中间件，但这样容易遭受中间人攻击 在view视图中添加装饰器 12345678910111213141516171819202122232425262728293031323334353637383940414243from django.views.decorators.csrf import csrf_exemptfrom django.views.decorators.clickjacking import xframe_options_exempt# 网页中无法添加csrf token， 可在view函数处添加装饰器csrf_exempt(存放于包django.views.decorators.csrf中)@xframe_options_exempt@csrf_exemptdef wiki_upload(request, project_id): &quot;&quot;&quot; markdown插件上传图片 &quot;&quot;&quot; result = &#123; &apos;success&apos;: 0, &apos;message&apos;: None, &apos;url&apos;: None, &#125; image_object = request.FILES.get(&apos;editormd-image-file&apos;) if not image_object: result[&apos;message&apos;] = &quot;文件不存在&quot; return JsonResponse(result) ext = image_object.name.rsplit(&apos;.&apos;)[-1] # 获取文件后缀名 key = &quot;&#123;&#125;.&#123;&#125;&quot;.format(uid(request.tracer.user.mobile_phone), ext) # 文件对象上传到当前项目的桶中 image_url = upload_file( bucket=request.tracer.project.bucket, region=request.tracer.project.region, file_object=image_object, key=key, ) print(image_url) result = &#123; &apos;success&apos;: 1, &apos;message&apos;: None, &apos;url&apos;: image_url, &#125; print(result) print(JsonResponse(result)) return JsonResponse(result) 在settings中设置X_FRAME_OPTIONS = ‘SAMEORIGIN’ 解决后 可以正常上传]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Anaconda笔记]]></title>
    <url>%2F2019%2F05%2F25%2FAnaconda%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[conda install nb_conda]]></content>
  </entry>
  <entry>
    <title><![CDATA[Python3+Django2+xadmin项目踩坑记录]]></title>
    <url>%2F2019%2F04%2F11%2FPython3-Django2-xadmin%E9%A1%B9%E7%9B%AE%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[Models的相关问题 先执行命令创建四个app 1234python manage.py startapp coursespython manage.py startapp userspython manage.py startapp operationpython manage.py startapp organization 修改settings.py中INSTALLED_APPS模块,注册四个app 1234567891011121314INSTALLED_APPS = [ &apos;django.contrib.admin&apos;, &apos;django.contrib.auth&apos;, &apos;django.contrib.contenttypes&apos;, &apos;django.contrib.sessions&apos;, &apos;django.contrib.messages&apos;, &apos;django.contrib.staticfiles&apos;, &apos;courses&apos;, &apos;operation&apos;, &apos;organization&apos;, &apos;users&apos;, &apos;xadmin&apos;, &apos;crispy_forms&apos;,] 创建UserProfile模型时,继承了AbstractUser类(from django.contrib.auth.models import AbstractUser) 使用此类时需要在settings.py中添加一行代码 AUTH_USER_MODEL = ‘users.UserProfile’users是app的名字,UserProfile是users中models.py中类的名称 在models.py中定义类时,使用到外键,需要添加on_delete=models.CASCADE 来约束外键删除, 连接数据库: 先修改settings.py中的配置,NAME是MySQL中database的名字, USER是数据库用户名,PASSWORD是数据库密码, 安装mysqlclient, 在pycharm中安装或者使用相应的包管理器安装, 执行 12python manage.py makemigrationspython manage.py migrate 迁移数据库. 为了防止项目结构混乱,在根目录下建一个Python Package,将四个文件全部拖如文件中 两个复选框全部取消勾选,移动完成后会有一些包导入时路径不对,将apps右键 –&gt; Mark Directory as –&gt; sources root ,此时在Pycharm中run这个项目不会出现问题,在命令行中运行会因为根目录不正确出现错误. 12345678910111213141516171819202122232425(base) alroy@Alan  ~/PycharmProjects/RBQ  python manage.py runserver Unhandled exception in thread started by &lt;function check_errors.&lt;locals&gt;.wrapper at 0x7f557788fd90&gt;Traceback (most recent call last): File &quot;/home/alroy/anaconda3/lib/python3.7/site-packages/django/utils/autoreload.py&quot;, line 225, in wrapper fn(*args, **kwargs) File &quot;/home/alroy/anaconda3/lib/python3.7/site-packages/django/core/management/commands/runserver.py&quot;, line 109, in inner_run autoreload.raise_last_exception() File &quot;/home/alroy/anaconda3/lib/python3.7/site-packages/django/utils/autoreload.py&quot;, line 248, in raise_last_exception raise _exception[1] File &quot;/home/alroy/anaconda3/lib/python3.7/site-packages/django/core/management/__init__.py&quot;, line 337, in execute autoreload.check_errors(django.setup)() File &quot;/home/alroy/anaconda3/lib/python3.7/site-packages/django/utils/autoreload.py&quot;, line 225, in wrapper fn(*args, **kwargs) File &quot;/home/alroy/anaconda3/lib/python3.7/site-packages/django/__init__.py&quot;, line 24, in setup apps.populate(settings.INSTALLED_APPS) File &quot;/home/alroy/anaconda3/lib/python3.7/site-packages/django/apps/registry.py&quot;, line 89, in populate app_config = AppConfig.create(entry) File &quot;/home/alroy/anaconda3/lib/python3.7/site-packages/django/apps/config.py&quot;, line 90, in create module = import_module(entry) File &quot;/home/alroy/anaconda3/lib/python3.7/importlib/__init__.py&quot;, line 127, in import_module return _bootstrap._gcd_import(name[level:], package, level) File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 1006, in _gcd_import File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 983, in _find_and_load File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 965, in _find_and_load_unlockedModuleNotFoundError: No module named &apos;users&apos; 在根目录的settings.py中添加两行代码12import syssys.path.insert(0,os.path.join(BASE_DIR, &apos;apps&apos;)) sys.path.insert(0,os.path.join(BASE_DIR, &#39;apps&#39;))定义搜索路径的优先顺序，序号从0开始，表示最大优先级，sys.path.insert()加入的也是临时搜索路径，程序退出后失效。 安装xadmin xadmin的优点见官网 这部分搞了半天,忘记去Google了,解决之后才发现自己很**,我安装方法是 直接conda install -n django xadmin 安装的是xadmin 0.6版本的,和Django2不兼容,运行会有各种神仙报错,就不贴截图了. xadmin的Github上给了Django2的安装方法,看到官网有安装方法,心中更是一万匹***奔腾而过,切换到对应的环境中conda activate django pip install git+git://github.com/shwsfc/xadmin.git@django2 配置用户上传media文件夹在settings.py中添加这两行代码将media文件夹添加到项目路径中, MEDIA_URL = &#39;/media/&#39; MEDIA_ROOT = os.path.join(BASE_DIR, &#39;media&#39;) 在TEMPLATES部分的OPTIONS中加入&#39;django.template.context_processors.media&#39;,即可在前端中使用((MEDIA_URL))(‘(‘替换成{)来访问用户上传的文件 为每个app分配一个url在根目录的urls.py中设置url指向到organization下的urls文件,设置namespace为org,在organization下的urls中先声明 app_name=’org’ url(r&apos;^org/&apos;, include(&apos;organization.urls&apos;,namespace=&apos;org&apos;)), 将每个url设置name的好处,变更类名或者地址不需要修改前端页面的url配置(前端使用url方法(%url &#39;org:test&#39;%)(‘(‘小括号替换为大括号))]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客中插入图片]]></title>
    <url>%2F2019%2F04%2F06%2FHexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[hexo博客中如何插入图片1. 将根目录下的配置文件 _config.yml 中的post_asset_folder选项设置true123456789101112131415# Writing42 new_post_name: :title.md # File name of new posts43 default_layout: post44 titlecase: false # Transform title into titlecase45 external_link: true # Open external links in new tab46 filename_case: 047 render_drafts: false48 post_asset_folder: true49 relative_link: false50 future: true51 highlight:52 enable: true53 line_number: true54 auto_detect: false55 tab_replace: 2. 在你的hexo目录下执行这句话npm install hexo-asset-image –save，这是下载安装一个可以上传本地图片的插件：12345678910111213141516(base) alroy@Alan  ~/Github/hexo-next  sudo proxychains4 npm install hexo-asset-image --save[sudo] password for alroy: [proxychains] config file found: /etc/proxychains.conf[proxychains] preloading /usr/lib/libproxychains4.so[proxychains] DLL init: proxychains-ng 4.13-git-10-g1198857[proxychains] DLL init: proxychains-ng 4.13-git-10-g1198857[proxychains] Strict chain ... 127.0.0.1:1090 ... registry.npmjs.org:443 ... OK[proxychains] Strict chain ... 127.0.0.1:1090 ... registry.npmjs.org:443 ... OK[proxychains] Strict chain ... 127.0.0.1:1090 ... registry.npmjs.org:443 ... OK[proxychains] Strict chain ... 127.0.0.1:1090 ... registry.npmjs.org:443 ... OKnpm WARN babel-eslint@10.0.1 requires a peer of eslint@&gt;= 4.12.1 but none is installed. You must install peer dependencies yourself.npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.7 (node_modules/fsevents):npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.7: wanted &#123;&quot;os&quot;:&quot;darwin&quot;,&quot;arch&quot;:&quot;any&quot;&#125; (current: &#123;&quot;os&quot;:&quot;linux&quot;,&quot;arch&quot;:&quot;x64&quot;&#125;)+ hexo-asset-image@0.0.3added 13 packages from 11 contributors in 22.144s 3. 下载完成之后,下次执行 hexo new post Hexo博客中插入图片生成博客文章时, 会在/source/_posts下生成一个同名文件夹12345678910(base) alroy@Alan  ~/Github/hexo-next/source/_posts  tree.├── hello-world.md├── Hexo-Deploy-ssh-Permission-denied.md├── Hexo博客中插入图片├── Hexo博客中插入图片.md├── Python实现BFS和DFS.md└── 海子逝世三十周年.md1 directory, 5 files 4. 在文章中想引入图片时, 将图片先复制到相应的文件夹中, 再使用MarkDown语法将图片插入至文章中 5. 5 最后检查一下，hexo g生成页面后，进入public\2019\04\06\index.html文件中查看相关字段，可以发现，html标签内的语句是&lt;img src=&quot;2019/04/06/xxxx/图片名.jpg&quot;&gt;，而不是&lt;img src=&quot;xxxx/图片名.jpg&gt;。这很重要，关乎你的网页是否可以真正加载你想插入的图片。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python实现BFS和DFS]]></title>
    <url>%2F2019%2F04%2F06%2FPython%E5%AE%9E%E7%8E%B0BFS-DFS%2F</url>
    <content type="text"><![CDATA[前言 广度优先搜索算法（英语：Breadth-First-Search，缩写为BFS），又译作宽度优先搜索，或横向优先搜索，是一种图形搜索算法。简单的说，BFS是从根节点开始，沿着树的宽度遍历树的节点。如果所有节点均被访问，则算法中止。 深度优先搜索算法（英语：Depth-First-Search，DFS）是一种用于遍历或搜索树或图的算法。沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点v的所在边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。属于盲目搜索。深度优先搜索是图论中的经典算法，利用深度优先搜索算法可以产生目标图的相应拓扑排序表，利用拓扑排序表可以方便的解决很多相关的图论问题，如最大路径问题等等 原理广度优先搜索 首先将根节点放入队列 从队列中取出第一个节点,并检验它是否为目标. 如果找到目标,则结束搜索并回传结果 否则将它所有尚未检验过的直接子节点加入队列中. 若队列为空,表示整张图都检查过了–亦即图中没有欲搜索的目标.结束搜索并回传“找不到目标”。 重复步骤2. 需要使用队列这一数据结构 假设以A为起点,与A点直接相连的点是 B,C ,此时广度优先遍历序列为A,B,C, 将BC入队,此时与B节点直接相连的是C和D,C已经在Queue中,所以下一个节点应是D,此时队列中为ABCD.与C节点相连的且未遍历过的节点为E, 所以将E入队,此时未遍历的节点为D,E, 与D直接相连的节点F入队即可得到广度优先遍历ABCDEF. 深度优先搜索 首先将根节点放入队列中。 从队列中取出第一个节点，并检验它是否为目标。 如果找到目标，则结束搜寻并回传结果。 否则将它某一个尚未检验过的直接子节点加入队列中。 重复步骤2。 如果不存在未检测过的直接子节点。 将上一级节点加入队列中。 重复步骤2。 重复步骤4。 若队列为空，表示整张图都检查过了——亦即图中没有欲搜寻的目标。结束搜寻并回传“找不到目标”。 需要使用栈这一数据结构 深度优先搜索过程: 深度优先搜索类似于树的先序遍历,正如其名称, 这种搜索算法所遵循的搜索策略是尽可能”深”地搜索一个图, 它的基本思想: 假设以A为起点,然后由A出发,访问与A邻接且未被访问的任一顶点B,再访问与B邻接且未被访问的顶点C,再访问与C邻接且未被访问的顶点E……重复上述过程.当不能再继续向下访问时,依次退回到最近被访问的顶点,若它还有邻接顶点未被访问过,则从该点开始继续上述搜索过程,直到图中所有顶点均被访问过为止.一般情况下,一个图的BFS和DFS不唯一. Python实现BFS12345678910111213141516171819202122232425262728293031graph = &#123; &quot;A&quot;:[&quot;B&quot;, &quot;C&quot;], # 与A相连的节点是B,C &quot;B&quot;:[&quot;A&quot;, &quot;C&quot;, &quot;D&quot;], # 与B相连的节点是A,C,D &quot;C&quot;:[&quot;A&quot;, &quot;B&quot;, &quot;D&quot;, &quot;E&quot;], &quot;D&quot;:[&quot;B&quot;, &quot;C&quot;, &quot;E&quot;, &quot;F&quot;], &quot;E&quot;:[&quot;C&quot;, &quot;D&quot;], &quot;F&quot;:[&quot;D&quot;] &#125;def BFS(graph, s): queue = [] # 初始化一个空队列 queue.append(s) # 将所有节点入队列 seen = set() seen.add(s) parent = &#123;s : None&#125; while(len(queue) &gt; 0): vertex = queue.pop(0) nodes = graph[vertex] for w in nodes: if w not in seen: queue.append(w) seen.add(w) parent[w] = vertex print(vertex) return parentparent = BFS(graph, &quot;E&quot;)for key in parent: print(key, parent[key]) DFS123456789101112131415161718192021222324graph = &#123; &quot;A&quot;:[&quot;B&quot;, &quot;C&quot;], &quot;B&quot;:[&quot;A&quot;, &quot;C&quot;, &quot;D&quot;], &quot;C&quot;:[&quot;A&quot;, &quot;B&quot;, &quot;D&quot;, &quot;E&quot;], &quot;D&quot;:[&quot;B&quot;, &quot;C&quot;, &quot;E&quot;, &quot;F&quot;], &quot;E&quot;:[&quot;C&quot;, &quot;D&quot;], &quot;F&quot;:[&quot;D&quot;] &#125;def DFS(graph, s): stack = [] stack.append(s) seen = set() seen.add(s) while(len(stack) &gt; 0): vertex = stack.pop() nodes = graph[vertex] for w in nodes: if w not in seen: stack.append(w) seen.add(w) print(vertex)DFS(graph, &quot;A&quot;)]]></content>
      <categories>
        <category>Python</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>BFS</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈Docker]]></title>
    <url>%2F2019%2F04%2F05%2F%E6%B5%85%E8%B0%88Docker%2F</url>
    <content type="text"><![CDATA[2013年发布至今， Docker一直广受瞩目，被认为可能会改变软件行业。今天就简单说说Docker. 一.Docker的优点持续部署与测试Docker在开发与运维的世界中具有极大的吸引力，因为它能保持跨环境的一致性。在开发与发布的生命周期中，不同的环境具有细微的不同，这些差异可能是由于不同安装包的版本和依赖关系引起的。然而，Docker可以通过确保从开发到产品发布整个过程环境的一致性来解决这个问题*Docker容器通过相关配置，保持容器内部所有的配置和依赖关系始终不变。最终，你可以在开发到产品发布的整个过程中使用相同的容器来确保没有任何差异或者人工干预。 使用Docker，你还可以确保开发者不需要配置完全相同的产品环境，他们可以在他们自己的系统上通过VirtualBox建立虚拟机来运行Docker容器。Docker的魅力在于它同样可以让你在亚马逊EC2实例上运行相同的容器。如果你需要在一个产品发布周期中完成一次升级，你可以很容易地将需要变更的东西放到Docker容器中，测试它们，并且使你已经存在的容器执行相同的变更。这种灵活性就是使用Docker的一个主要好处。和标准部署与集成过程一样，Docker可以让你构建、测试和发布镜像，这个镜像可以跨多个服务器进行部署。哪怕安装一个新的安全补丁，整个过程也是一样的。你可以安装补丁，然后测试它，并且将这个补丁发布到产品中。 多云平台Docker最大的好处之一就是可移植性。在过去的几年里，所有主流的云计算提供商，包括亚马逊AWS和谷歌的GCP，都将Docker融入到他们的平台并增加了各自的支持。Docker容器能运行在亚马逊的EC2实例、谷歌的GCP实例、Rackspace服务器或者VirtualBox这些提供主机操作系统的平台上。举例来说，如果运行在亚马逊EC2实例上的Docker容器能够很容易地移植到其他几个平台上，比如说VirtualBox，并且达到类似的一致性和功能性，那这将允许你从基础设施层中抽象出来。除了AWS和GCP，Docker在其他不同的IaaS提供商也运行的非常好，例如微软的Azure、OpenStack和可以被具有不同配置的管理者所使用的Chef、Puppet、Ansible等。 环境标准化和版本控制通过上面的讨论，Docker容器可以在不同的开发与产品发布生命周期中确保一致性，进而标准化你的环境。除此之外，Docker容器还可以像git仓库一样，可以让你提交变更到Docker镜像中并通过不同的版本来管理它们。设想如果你因为完成了一个组件的升级而导致你整个环境都损坏了，Docker可以让你轻松地回滚到这个镜像的前一个版本。这整个过程可以在几分钟内完成，如果和虚拟机的备份或者镜像创建流程对比，那Docker算相当快的，它可以让你快速地进行复制和实现冗余。此外，启动Docker就和运行一个进程一样快。 隔离性Docker可以确保你的应用程序与资源是分隔开的。几个月前，Gartner发表了一篇报告，这份报告说明了运行Docker 容器进行资源隔离的效果和虚拟机（VM）管理程序一样的好，但是管理与控制方面还需要进行完善。 我们考虑这样一个场景，你在你的虚拟机中运行了很多应用程序，这些应用程序包括团队协作软件（例如Confluence）、问题追踪软件（例如JIRA）、集中身份管理系统（例如Crowd）等等。由于这些软件运行在不同的端口上，所以你必须使用Apache或者Nginx来做反向代理。到目前为止，一切都很正常，但是随着你的环境向前推进，你需要在你现有的环境中配置一个内容管理系统（例如Alfresco）。这时候有个问题发生了，这个软件需要一个不同版本的Apache Tomcat，为了满足这个需求，你只能将你现有的软件迁移到另一个版本的Tomcat上，或者找到适合你现有Tomcat的内容管理系统（Alfresco）版本。 对于上述场景，使用Docker就不用做这些事情了。Docker能够确保每个容器都拥有自己的资源，并且和其他容器是隔离的。你可以用不同的容器来运行使用不同堆栈的应用程序。除此之外，如果你想在服务器上直接删除一些应用程序是比较困难的，因为这样可能引发依赖关系冲突。而Docker可以帮你确保应用程序被完全清除，因为不同的应用程序运行在不同的容器上，如果你不在需要一款应用程序，那你可以简单地通过删除容器来删除这个应用程序，并且在你的宿主机操作系统上不会留下任何的临时文件或者配置文件。 除了上述好处，Docker还能确保每个应用程序只使用分配给它的资源（包括CPU、内存和磁盘空间）。一个特殊的软件将不会使用你全部的可用资源，要不然这将导致性能降低，甚至让其他应用程序完全停止工作。 安全性如上所述，Gartner也承认Docker正在快速地发展。从安全角度来看，Docker确保运行在容器中的应用程序和其他容器中的应用程序是完全分隔与隔离的，在通信流量和管理上赋予你完全的控制权。Docker容器不能窥视运行在其他容器中的进程。从体系结构角度来看，每个容器只使用着自己的资源（从进程到网络堆栈）。 作为紧固安全的一种手段，Docker将宿主机操作系统上的敏感挂载点（例如/proc和/sys）作为只读挂载点，并且使用一种写时复制系统来确保容器不能读取其他容器的数据。Docker也限制了宿主机操作系统上的一些系统调用，并且和SELinux与AppArmor一起运行的很好。此外，在Docker Hub上可以使用的Docker镜像都通过数字签名来确保其可靠性。由于Docker容器是隔离的，并且资源是受限制的，所以即使你其中一个应用程序被黑，也不会影响运行在其它Docker容器上的应用程序。 环境配置软件开发的第一件事就是配置开发环境,用户计算机的环境都不相同，你如何使自己开发的软件，能在别的机器跑起来？用户必须保证两件事：操作系统的设置，各种库和组件的安装。只有它们都正确，软件才能运行。Docker可以把软件和开发环境一并打包. 二.虚拟机虚拟机（virtual machine）就是带环境安装的一种解决方案。它可以在一种操作系统里面运行另一种操作系统，比如在 Windows 系统里面运行 Linux 系统。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。 虽然用户可以通过虚拟机还原软件的原始环境。但是，这个方案有几个缺点。 资源占用多 虚拟机会独占一部分内存和硬盘空间。它运行的时候，其他程序就不能使用这些资源了。哪怕虚拟机里面的应用程序，真正使用的内存只有 1MB，虚拟机依然需要几百 MB 的内存才能运行。 冗余步骤多 虚拟机是完整的操作系统，一些系统级别的操作步骤，往往无法跳过，比如用户登录。 启动慢 启动操作系统需要多久，启动虚拟机就需要多久。可能要等几分钟，应用程序才能真正运行。 三.Linux 容器由于虚拟机存在这些缺点，Linux 发展出了另一种虚拟化技术：Linux 容器（Linux Containers，缩写为 LXC）。 Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。或者说，在正常进程的外面套了一个保护层。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。 由于容器是进程级别的，相比虚拟机有很多优势。 启动快 容器里面的应用，直接就是底层系统的一个进程，而不是虚拟机内部的进程。所以，启动容器相当于启动本机的一个进程，而不是启动一个操作系统，速度就快很多。 资源占用少 容器只占用需要的资源，不占用那些没有用到的资源；虚拟机由于是完整的操作系统，不可避免要占用所有资源。另外，多个容器可以共享资源，虚拟机都是独享资源。 体积小 容器只要包含用到的组件即可，而虚拟机是整个操作系统的打包，所以容器文件比虚拟机文件要小很多。 总之，容器有点像轻量级的虚拟机，能够提供虚拟化的环境，但是成本开销小得多。 四. Docker是什么? Docker is an open-source project that automates the deployment of applications inside software containers, by providing an additional layer of abstraction and automation of operating-system-level virtualization on Linux. Docker uses the resource isolation features of the Linux kernel such as cgroups and kernel namespaces, and a union-capable filesystem such as aufs and others to allow independent “containers” to run within a single Linux instance, avoiding the overhead of starting and maintaining virtual machines.Docker是一个开放源代码软件项目，让应用程序布署在软件容器下的工作可以自动化进行，借此在Linux操作系统上，提供一个额外的软件抽象层，以及操作系统层虚拟化的自动管理机制。Docker利用Linux核心中的资源分离机制，例如cgroups，以及Linux核心命名空间（name space），来建立独立的软件容器（containers）。这可以在单一Linux实体下运作，避免启动一个虚拟机器造成的额外负担。——摘自维基百科 五. 安装DockerDocker包括两个版本,docker ce(Community Edition)社区版和docker ee(Enterprise Edition)企业版.本篇所有内容只针对社区版. Docker的安装方式请参考官方文档 安装完成执行docker命令会报 permission denied 没权限的错误 一些Windowsers会说用root用户啊……另一些有基本常识,知道不应该使用root的人可能会说,那用sudo docker吧,这两种方法都是不对的,或者说不合适. 说使用root的人，应该回去好好学习一下 Linux 权限常识。一般 不应该直接使用 root 用户，直接使用 root 用户不仅仅是严重的违反了安全规范，而且也极容易造成操作事故。这不是 Windows 世界，Linux/Unix 世界是有严格的权限要求的，只应该使用最小的权限做事情。如果还不熟悉 Linux 权限机制，那就去学习一下，不要把 Windows的坏毛病带过来。 说使用 sudo docker 的人，思路是对的，因为理解了平时操作应该使用普通用户，只有在需要的时候，才 sudo 提升权限进行操作。但是问题就在这个需要二字上，事实上，不需要 root 权限就可以执行 docker 命令。 其实如果看过官方安装文档的话都会知道，只需要将操作 docker 的用户，加入 docker 组，那么该用户既拥有了操作 docker 的权限。因此,只需要执行: 1sudo usermod -aG docker $USER 把当前用户加入到docker组, 退出重新登录系统后,执行docker info 看一下,会发现可以不用sudo docker来执行docker命令了 如果需要添加别的用户，将其中的 $USER换成对应的用户名即可。 将用户添加到 docker 组，可以避免 root 权限误操作的问题，但是由于 dockerd 引擎是运行在 root 用户下的，而 docker 组成员有权限指挥 dockerd 引擎来做很多事情，因此，该用户实际上是拥有了 root 的权限的。因此不要误解了将当前用户加入 docker 组的初衷，这和赋予用户 sudo 权力是一样的，可不是说这个用户就没有 root 权限了。这样做，只是不再需要使用 sudo 了，也降低了使用 sudo 时误操作的可能。 Docker是C-S架构,需要在本地先启动docker服务.12345# service 命令的用法$ sudo service docker start# systemctl 命令的用法$ sudo systemctl start docker 六.image文件Docker 把应用程序及其依赖，打包在 image 文件里面。只有通过这个文件，才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。 image 是二进制文件。实际开发中，一个 image 文件往往通过继承另一个 image 文件，加上一些个性化设置而生成。 对Docker images的操作1234# 列出本机的所有 image 文件docker images# 删除 image 文件docker rmi xxx 七.Hello World!docker 官方制作了Hello World的镜像.使用1docker run hello-world docker会先检查本地有没有hello-world镜像,没有的话会从官方仓库中拉取. docker pull 慢怎么解决首先，要“感谢”伟大的墙。 然后，我们可以使用 Docker 镜像加速器来解决这个问题，加速器就是镜像、代理的概念。国内有不少机构提供了免费的加速器以方便大家使用，这里列出一些常用的加速器服务： Docker 官方的中国镜像加速器：从2017年6月9日起，Docker 官方提供了在中国的加速器，以解决墙的问题。不用注册，直接使用加速器地址：https://registry.docker-cn.com 即可。 中国科技大学的镜像加速器：中科大的加速器不用注册，直接使用地址 https://docker.mirrors.ustc.edu.cn/ 配置加速器即可。进一步的信息可以访问：http://mirrors.ustc.edu.cn/help/dockerhub.html?highlight=docker 阿里云加速器：注册阿里云开发账户(免费的)后，访问这个链接就可以看到加速器地址： https://cr.console.aliyun.com/#/accelerator DaoCloud 加速器：注册 DaoCloud 账户(支持微信登录)，然后访问： https://www.daocloud.io/mirror#accelerator-doc 访问官方文档很慢怎么办再次感谢伟大的 墙我们可以本地运行 Docker 官方文档的网站，以 docker 的方式：1$ docker run -d -p 80:4000 docs/docker.github.io 这样访问 Docker 宿主的 80 端口，如 http://localhost，就会看到官网文档了。 八. Docker常用命令基础类 查看Docker信息 12345678# 查看docker版本docker version# 显示docker系统的信息docker info# 日志信息docker logs# 故障检查docker status 本地镜像 查看本地镜像 docker images1234567(base) alroy@Alan  ~  docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEnginx latest 27a188018e18 2 weeks ago 109MBubuntu latest 94e814e2efa8 7 weeks ago 88.9MBhello-world latest fce289e99eb9 4 months ago 1.84kBzsnmwy/bilihelper latest b108cce8590c 6 months ago 96.3MBzsnmwy/bilibili-live-tools latest e2b0e619d00a 9 months ago 112MB 删除本地镜像 docker rmi hello-world12(base) alroy@Alan  ~  docker rmi hello-worldError response from daemon: conflict: unable to remove repository reference &quot;hello-world&quot; (must force) - container 93b3b3af6661 is using its referenced image fce289e99eb9 正在运行的容器使用的镜像无法删除,想删除需先停止容器再删除镜像 查看镜像详情 docker inspect [ 镜像名 or 镜像 id ] 打包本地镜像, 使用压缩包来完成迁移 docker save [ 镜像名 ] &gt; [ 文件路径 ] 12345# 默认为文件流输出docker save ubuntu &gt; /home/alroy/ubuntu.img# 或者使用 &apos;-o&apos; 选项指定输出文件路径docker save -o ubuntu &gt; /home/alroy/ubuntu.img 导入镜像压缩包 docker load &lt; [ 文件路径 ] 12(base) ✘ alroy@Alan  ~  docker load -i /home/alroy/ubuntu.img Loaded image: ubuntu:latest 修改镜像tag docker tag [ 镜像名 or 镜像 id ] [ 新镜像名 ]:[ 新 tag ] 1docker tag hello-world:latest hello-world:test 日志 docker logs -f &lt;容器名orID&gt; journalctl 日志工具使用 123456789101112# 最后行数的日志journalctl -n# 详细信息journalctl -f# 本次启动后的所有日志journalctl -b# 查看启动记录journalctl --list-boots# 查看某次运行过程中的日志sudo journalctl -b [启动顺序号，或者启动hash]# 查看记录中指定单元 docker.service 的日志journalctl -u docker.service 查看容器信息 1234567891011121314# 查看当前运行的容器docker ps# 查看全部容器docker ps -a# 查看全部容器的id和信息docker ps -a -q# 查看全部容器占用的空间docker ps -as# 查看一个正在运行容器进程，支持 ps 命令参数docker top# 查看容器的示例idsudo docker inspect -f &apos;&#123;&#123;.Id&#125;&#125;&apos; [id]# 检查镜像或者容器的参数，默认返回 JSON 格式docker inspect 启动停止容器等操作 123456789docker start|stop|restart [id]# 暂停|恢复 某一容器的所有进程docker pause|unpause [id]# 杀死一个或多个指定容器进程docker kill -s KILL [id]# 停止全部运行的容器docker stop `docker ps -q`# 杀掉全部运行的容器docker kill -s KILL `docker ps -q` 交互式进入容器 1234docker exec -it &#123;&#123;containerName or containerID&#125;&#125; bashdocker exec -i &#123;&#123;containerName or containerID&#125;&#125; bashdocker exec -t &#123;&#123;containerName or containerID&#125;&#125; bashdocker exec -d &#123;&#123;containerName or containerID&#125;&#125; bash run命令常用选项 选项 说明 -d 后台运行容器, 并返回容器ID；不指定时, 启动后开始打印日志, Ctrl + C 退出命令同时会关闭容器 -i 以交互模式运行容器, 通常与 -t 同时使用； -t 为容器重新分配一个伪输入终端, 通常与 -i 同时使用 –name “anyesu-container” 为容器指定一个别名, 不指定时随机生成 -h docker-anyesu 设置容器的主机名, 默认随机生成 –dns 8.8.8.8 指定容器使用的 DNS 服务器, 默认和宿主机一致 -e docker_host=172.17.0.1 设置环境变量 –cpuset=”0-2” or –cpuset=”0,1,2” 绑定容器到指定 CPU 运行 -m 100M 设置容器使用内存最大值 –net bridge 指定容器的网络连接类型, 支持 bridge / host / none / container 四种类型 –ip 172.18.0.13 为容器分配固定 ip ( 需要使用自定义网络 ) –expose 8081 –expose 8082 开放一个端口或一组端口, 会覆盖镜像设置中开放的端口 -p [宿主机端口]:[容器内端口] 宿主机到容器的端口映射, 可指定宿主机的要监听的 ip, 默认为 0.0.0.0 -P 注意是大写的, 宿主机随机指定一组可用的端口映射容器 expose 的所有端口 -v [宿主机目录路径]:[容器内目录路径] 挂载宿主机的指定目录 ( 或文件 ) 到容器内的指定目录 ( 或文件 ) –add-host [主机名]:[ip] 为容器 hosts 文件追加 host , 默认会在 hosts 文件最后追加内容：[主机名]:[容器ip] –volumes-from [其他容器名] 将其他容器的数据卷添加到此容器 –link [其他容器名]:[在该容器中的别名] 添加链接到另一个容器, 在本容器 hosts 文件中加入关联容器的记录, 效果类似于 –add-host 剩个坑以后想起来再填(]]></content>
      <categories>
        <category>云</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>虚拟化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[海子逝世三十周年]]></title>
    <url>%2F2019%2F03%2F26%2F%E6%B5%B7%E5%AD%90%E9%80%9D%E4%B8%96%E4%B8%89%E5%8D%81%E5%91%A8%E5%B9%B4%2F</url>
    <content type="text"><![CDATA[那是整整三十年前的今天。 黄昏，海子悄无声息地去了山海关，口袋里只有单程车票，没有酒钱。那是北方的早春，天气还没有暖和起来，小酒馆门口挂着厚厚的门帘，街角的玉兰树上光秃秃的，花苞还没有长出来。 海子对酒馆老板说：“我给大家朗读我的诗，你能不能给我酒喝？”老板回答：“我可以给你酒喝，但你别在这儿朗诵。”周围的人笑起来，海子悻悻走开，再也没有回来。 他找到一处无人的铁轨，躺好，平静地等待火车的到来，就像在等待一首优美的诗歌。那悲壮惨烈的一幕和那首《太阳》中的意境几乎一模一样：12345正是黄昏时分无头英雄手指落日手指日落和天空眼含尘土和热血扶着马头倒下。 在夜色中 我有三次受难：流浪，爱情，生存 我有三种幸福：诗歌，王位，太阳 &lt;夜色&gt; 当众人齐集河畔 高声歌唱生活 我定会孤独返回空无一人的山峦 &lt;晨雨时光&gt; 你说你孤独 就像很久以前 长星照耀十三个州府的那种孤独 &lt;歌或哭&gt; 安徽八州五府,天上微弱的星光照耀着遥远的家乡,而自己在遥远的远方,”热闹是他们的,我什么也没有”,谁又能明白海子的孤独呢,又有谁能真正理解他的孤独呢!答案后来就都知道了. 在&lt;夏天的太阳&gt;中海子这样写道 我想到在白天出生的孩子一定是出于故意你来人间一趟你要看看太阳和你的心上人一起走在街上 海子把出生在太阳下的人看做是无比幸运的,是啊,能够直面阳光是多么美好的事情,心情失落的时候看看太阳,也会在心中重新升起希望吧,真的很羡慕这种人了. 2015年3月26，我去了西藏。 2018年3月26，我去了北京。 似乎是个巧合，又似乎冥冥之中自有安排，三月是个春暖花开的时间，希望是春天的主旋律，一切还没有那么糟糕、那么绝望，在这种时间里自杀似乎又是很好的选择，太宰治说，我本想这个冬日就死去，可最近拿到一套鼠色细条纹的麻制和服，是适合夏天穿的和服，所以我还是活到夏天吧。海子没有等到夏天就在山海关结束了自己的生命。自杀更让海子添加了几分神秘，不要去追究当年究竟发生了什么，让神秘更神秘，让永恒更永恒，他带着对诗歌精神的信念走入了永恒，却把“面朝大海，春暖花开”的梦想留给了后人，留给了我们，留给了世世代代的年轻人。从海子的诗中，我们可以感受热腾腾的生命气息，暂时忘却生活的黯淡与现实的迷茫。有人说，海子是个试金石，当海子不能打动你的时候，说明你身上少年的东西已经没了。我也相信，诗歌的存在是为了证明我们并未老去，并未被完全物化。 这位天才诗人，留下 今夜我遇见了世上的一切 但不会遇见你 的落寞，带着“喂马，劈柴，周游世界”的梦想，把阳光的温暖留在人间，却只给自己留下一个落日黄昏。 最后篡改一句不太合适的诗吧： 海子 今夜我不关心人类 我只想你]]></content>
      <categories>
        <category>随想</category>
      </categories>
      <tags>
        <tag>海子</tag>
        <tag>诗</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-Deploy-ssh-Permission-denied]]></title>
    <url>%2F2019%2F03%2F19%2FHexo-Deploy-ssh-Permission-denied%2F</url>
    <content type="text"><![CDATA[问题描述:使用hexo发布博客,配置完成之后执行 hexo g -d 出现如下错误1234567891011git@github.com: Permission denied (publickey).fatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists.FATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.htmlError: Spawn failed at ChildProcess.&lt;anonymous&gt; (/home/alroy/Github/hexo-next/node_modules/hexo-util/lib/spawn.js:52:19) at emitTwo (events.js:126:13) at ChildProcess.emit (events.js:214:7) at Process.ChildProcess._handle.onexit (internal/child_process.js:198:12) 简单Google一下之后,发现是Github上没有密钥的原因> ls ~/.ssh/> ssh-keygen -t rsa -C “youremail”> cat ~/.ssh/id_rsa.pub 登录github后，进入个人设置settings—>ssh and gpg keys–>new ssh key 添加即可。title自行命名]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Github</tag>
      </tags>
  </entry>
</search>
